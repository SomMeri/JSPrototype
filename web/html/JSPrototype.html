<!DOCTYPE HTML>
<html lang="en">
<head>
<title>JSPrototype</title>
<meta charset="utf-8">
<style type="text/css">
body {
	font-family: Monospace;
	font-size: 12px;
	background-color: #f0f0f0;
	margin: 0px;
	overflow: hidden;
}
</style>
</head>
<body>

	<script type="text/javascript" src="../js/ThreeCanvas.js"></script>
	<script type="text/javascript" src="../js/Cube.js"></script>
	<script type="text/javascript" src="../js/Robot.js"></script>
	<script type="text/javascript" src="../js/Plane.js"></script>
	<script type="text/javascript" src="../js/GameEngine.js"></script>
	<script type="text/javascript" src="../js/GraphicEngine.js"></script>

	<script type="text/javascript">

			var container, interval,
			camera, scene, renderer,
			projector, plane, cube, linesMaterial,
			color = 0,robotColor = 3,colors = [ 0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030 ],
			ray, brush, robotMesh,
			mouse3D, isMouseDown = false, onMouseDownPosition,
			radious = 1600, theta = 45, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60;
			
			var graphicEngine;
			var gameEngine = new GameEngine(graphicEngine);

			init();
			graphicEngine.render();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				appendUpperRow(container);
				
				initCamera();
				scene = new THREE.Scene();
				projector = new THREE.Projector();
				ray = new THREE.Ray( camera.position, null );

				initFictionalBottomLines(scene);
				initPlane(scene);
				initCube(scene);
				initRobot(scene);
				initLights(scene);
				
				onMouseDownPosition = new THREE.Vector2();

				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild(renderer.domElement);
				graphicEngine = new GraphicEngine(renderer, scene);
				graphicEngine.render();
				initEventListeners();
			}

			function appendUpperRow(container) {
				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '5px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<span style="color: #444; background-color: #fff; border-bottom: 1px solid #ddd; padding: 8px 10px; text-transform: uppercase;"><strong>0 - 9</strong>: colors, <strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel, <strong>drag</strong>: rotate | <a id="link" href="" target="_blank">share</a> <a href="javascript:save();">save</a> <a href="javascript:clear();">clear</a></span>';
				container.appendChild( info );
			}
			
			function initEventListeners() {
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );

				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
			}
			
			function initCamera() {
				camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
				camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
				camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
				camera.target.position.y = 200;
			}
			
			function initFictionalBottomLines(scene) {
				var geometry = new THREE.Geometry();
				geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( - 500, 0, 0 ) ) );
				geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 500, 0, 0 ) ) );

				linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

        		// paint bottom lines
				for ( var i = 0; i <= 20; i ++ ) {
					var line = new THREE.Line( geometry, linesMaterial );
					line.position.z = ( i * 50 ) - 500;
					scene.addObject( line );

					var line = new THREE.Line( geometry, linesMaterial );
					line.position.x = ( i * 50 ) - 500;
					line.rotation.y = 90 * Math.PI / 180;
					scene.addObject( line );
				}
			}
			
			function initPlane(scene) {
				plane = new THREE.Mesh( new Plane( 1000, 1000 ) );
				plane.rotation.x = - 90 * Math.PI / 180;
				scene.addObject( plane );
			}

			function initCube(scene) {
				//cursor cube (the light one, see throught it)
				cube = new Cube( 50 );
				// last parameter is transparency <-> solidness
				brush = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ], 0.5 ) );
				brush.position.y = 2000;
				brush.overdraw = true;
				scene.addObject( brush );
			}

			function initRobot(scene) {
				robot = new Robot( 50 );
				robotMesh = new THREE.Mesh( robot, new THREE.MeshColorFillMaterial( colors[ robotColor ], 1 ) );
				robotMesh.overdraw = true;
				placeObject(robotMesh, 0, 0, 0);
			}

			function initLights(scene) {
				var ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.addLight( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.x = 1;
				directionalLight.position.y = 1;
				directionalLight.position.z = 0.75;
				directionalLight.position.normalize();
				scene.addLight( directionalLight );

				var directionalLight = new THREE.DirectionalLight( 0x808080 );
				directionalLight.position.x = - 1;
				directionalLight.position.y = 1;
				directionalLight.position.z = - 0.75;
				directionalLight.position.normalize();
				scene.addLight( directionalLight );
			}
			//NOW removing
			function placeObject(object, x, y, z) {
				object.position.x = x * 50 + 25;
				object.position.y = y * 50 + 25;
				object.position.z = z * 50 + 25;
				object.overdraw = true;
				scene.addObject( object );
			}
			
			function onDocumentKeyDown( event ) {

				switch( event.keyCode ) {

					case 49: setBrushColor( 0 ); break;
					case 50: setBrushColor( 1 ); break;
					case 51: setBrushColor( 2 ); break;
					case 52: setBrushColor( 3 ); break;
					case 53: setBrushColor( 4 ); break;
					case 54: setBrushColor( 5 ); break;
					case 55: setBrushColor( 6 ); break;
					case 56: setBrushColor( 7 ); break;
					case 57: setBrushColor( 8 ); break;
					case 48: setBrushColor( 9 ); break;
					case 37: offsetObject( robotMesh, - 1, 0, 0 ); break;
					case 38: offsetObject( robotMesh, 0, 0, - 1 ); break;
					case 39: offsetObject( robotMesh, 1, 0, 0 ); break;
					case 40: offsetObject( robotMesh, 0, 0, 1 ); break;
				}

			}

			function onDocumentKeyUp( event ) {
			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				isMouseDown = true;

				onMouseDownTheta = theta;
				onMouseDownPhi = phi;
				onMouseDownPosition.x = event.clientX;
				onMouseDownPosition.y = event.clientY;
			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				if ( isMouseDown ) {

					theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
					phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

					phi = Math.min( 180, Math.max( 0, phi ) );

					camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
					camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
					camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
					camera.updateMatrix();

				}

				mouse3D = projector.unprojectVector( new THREE.Vector3( ( event.clientX / renderer.domElement.width ) * 2 - 1, - ( event.clientY / renderer.domElement.height ) * 2 + 1, 0.5 ), camera );
				ray.direction = mouse3D.subSelf( camera.position ).normalize();

				interact();
				graphicEngine.render();

			}

			function onDocumentMouseUp( event ) {

				event.preventDefault();

				isMouseDown = false;

				onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
				onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

				if ( onMouseDownPosition.length() > 5 ) {

					return;

				}

				var intersect, intersects = ray.intersectScene( scene );

				if ( intersects.length > 0 ) {

					intersect = intersects[ 0 ].object == brush ? intersects[ 1 ] : intersects[ 0 ];

					if ( intersect ) {
						var position = new THREE.Vector3().add( intersect.point, intersect.object.matrixRotation.transform( intersect.face.normal.clone() ) );
						var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
						placeObject(voxel, Math.floor( position.x / 50 ), Math.floor( position.y / 50 ), Math.floor( position.z / 50 ));
					}

				}

				interact();
				graphicEngine.render();

			}

			function setBrushColor( value ) {

				color = value;
				brush.material[ 0 ].color.setHex( colors[ color ] ^ 0x4C000000 );

				graphicEngine.render();

			}

			function offsetObject(object, x, y, z ) {
				var offset = new THREE.Vector3( x, y, z ).multiplyScalar( 50 );
				object.position.addSelf( offset );
				interact();
				graphicEngine.render();
			}

			function interact() {
				var position, intersect, intersects = ray.intersectScene( scene );

				if ( intersects.length > 0 ) {
					intersect = intersects[ 0 ].object != brush ? intersects[ 0 ] : intersects[ 1 ];
					
					if (intersects[ 0 ] == robotMesh || intersects[ 1 ] == robotMesh) {
					  alert(1);
					}

					if ( intersect ) {
						position = new THREE.Vector3().add( intersect.point, intersect.object.matrixRotation.transform( intersect.face.normal.clone() ) );

						brush.position.x = Math.floor( position.x / 50 ) * 50 + 25;
						brush.position.y = Math.floor( position.y / 50 ) * 50 + 25;
						brush.position.z = Math.floor( position.z / 50 ) * 50 + 25;

						return;
					}

				}

				brush.position.y = 2000;

			}

			// alrea
			function render() {
				renderer.render( scene, camera );
			}

			function save() {

				linesMaterial.color.setRGBA( 0, 0, 0, 0 );
				brush.position.y = 2000;
				graphicEngine.render();

				window.open( renderer.domElement.toDataURL('image/png'), 'mywindow' );

				linesMaterial.color.setRGBA( 0, 0, 0, 0.2 );
				graphicEngine.render();

			}

			function clear() {

				if ( !confirm( 'Are you sure?' ) ) {

					return

				}

				var i = 0;

				while ( i < scene.objects.length ) {

					object = scene.objects[ i ];

					if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

						scene.removeObject( object );
						continue;
					}

					i ++;
				}

				graphicEngine.render();

			}

		</script>

</body>
</html>
